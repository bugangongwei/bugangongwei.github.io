---
title: redis
date: 2021-08-16 14:10:00
tags: [redis]
categories: 数据库
comments: true
---

# 数据库
## redisServer
````C
typedef struct redisServer
{
  // ...
  // 服务器的数据库数量, 默认值是 16
  int dbnum;
  // 一个数组, 保存着数据库中所有的数据库
  redisDb *db;
  // ...
  // 记录 save 选项的数组, 服务器在多少秒内, 对数据库进行了多少次修改
  struct saveparam *saveparams;
  // ...
  // 修改计数器
  long long dirty
  // 上一次执行 save 的时间
  time_t lastsave;
};
````

## redisDb
````C
typedef struct redisDb
{
  // 数据库键空间, 保存着数据库中所有的键值对
  dict *dict;
  // 过期字典, 保存键的过期时间
  dict *expires
};
````

## 读写键空间时的维护操作
(1) 服务器根据键是否存在更新键空间 hit 次数或 miss 次数; ``` INFO stats ```
(2) 更新键的 LRU 时间, 用来计算键的闲置时间; ``` OBJECT idletime <key> ```
(3) 发现过期键, 先删除过期键, 再进行其他操作;
(4) 如果客户端使用 WATCH 监视了一个 key, 那么, 服务端对 key 的值进行修改之后, 会将 key 标记为 ‘dirty’; 然后 'dirty' 键的计数器加 1;
(5) 如果服务器开启了数据库通知功能, 那么对键进行修改之后, 服务器按照配置发送相应的数据库通知;

## 键过期
### 命令
- 可生存时间: EXPIRE, PEXPIRE
- 删除时间点: EXPIREAT, PEXPIREAT
- 剩余可生存时间: TTL, PTTL
- 删除过期时间设置: PERSIST
EXPIRE, PEXPORE, EXPIREAT 最终都是使用 PEXPIREAT 来实现的

### 过期键删除策略
Redis 服务器使用的是 [定期删除 + 惰性删除] 的策略
#### 定时删除: 在设置键的过期时间的同时, 创建一个定时器, 让定时器在键过期时间来临时, 删除过期键;
优势: 内存友好, 因为能够尽可能快地删除过期键
不足: 
(1) CPU 不友好, 太多的 CPU 耗费在定时删除过期键这件事情上, 可能影响响应时间和吞吐量;
(2) 效率低, Redis 的时间事件的实现方式是无需链表, 查询时间复杂度为 O(N);

#### 惰性删除: 读取键的时候判断键是否过期, 过期则删除;
优势: CPU 友好, 不会在无关的过期键上花费任何的 CPU 时间;
不足: 内存不友好, 毕竟过期键可以长时间霸占内存, 甚至造成内存泄漏;

#### 定期删除: 定期删除服务器中所有过期的键;

### 过期键对 RDB, AOF 和复制功能的影响
(1) SAVE 和 BGSAVE 时, 会对数据库中的键进行检查, 不会把过期键写入读到 RDB 中;
(2) 主服务器载入 RDB 时, 会把过期的键过滤掉;
(3) 从服务器载入 RDB 时, 加载所有的 key, 但是主从同步时, 从服务器会被清空, 所以, 最终不会留下过期键;
(4) 如果服务器以 AOF 的模式运行, 那么发生惰性删除或定期删除时, 程序会向 AOF 文件追加一条 DEL 命令;
(5) AOF 重写会对过期键进行过滤;
(6) 当服务器以复制模式运行时, 从服务器只有在接收到住服务器的 DEL 命令时, 才删除过期键;

## 数据库通知 SUBSCRIBE
(1) key-space-notification 键空间通知: 某个键执行了什么命令
(2) key-event-notification 键事件通知: 某个命令被什么键执行了
### nofity-keyspace-events 服务器配置通知类型
(1) AKE: key-space-notification + key-event-notification
(2) AK: key-space-notification
(3) AE: key-event-notification
(4) K$: 只发送与字符串有关的键空间通知;
(5) EI: 只发送和列表键有关的键事件通知;

# RDB 持久化
## 载入
只有服务器启动时才会自动载入 RDB 文件: 服务器启动 -> 执行载入程序 -> 是否已开启 AOF 持久化功能? -> 是则载入 AOF 文件, 否认阻塞地载入 RDB 文件;
## 持久化
SAVE - 阻塞执行; BGSAVE - 创建子进程执行;
BGSAVE 运行期间, 服务器会禁止所有的 SAVE 和 BGSAVE 命令执行, 防止对底层函数 rdbSave 进行竞争;
BGSAVE 运行期间, BGREWRITEAOF 命令被延迟到 BGSAVE 运行完再运行;
BGREWRITEAOF 运行期间, BGSAVE 命令被拒绝执行;
BGREWRITEAOF 和 BGSAVE 同为子进程却不能同时运行, 是为性能考虑, 毕竟两者都要操作磁盘写入, 很耗费性能;
## 服务器设置 BGSAVE 启动的条件
serverCron 默认每 100ms 执行一次, 通过 saveparams, dirty, lastsave 判断是否需要启动 BGSAVE;
## RDB 文件结构
|| REDIS || db_version || databases || EOF || check_sum ||
| 4 字节 | 4 字节 | 任意字节数 | 1 字节 | 8 字节 |
od -c xxx.rdb 以 ASCII 码形式查看 xxx.rdb 文件的值

# AOF 持久化
## RDB 持久化与 AOF 持久化的区别=
RDB 持久化保存的是数据库中的键值对; AOF 持久化保存 Redis 服务器中所执行的写命令;

## AOF 文件的写入与同步
服务器处理文件事件时, 如果执行了写命令, 则把命令内容追加到 aof_buf 缓冲区中;
appendfsync 选项表示 aof_buf 缓冲区写入到 AOF 文件的策略:
(1) always: 每执行一次事件循环都要清一次 aof_buf
(2) everysec: 每秒执行一次 aof_buf 清空, 默认值
(3) no: 把控制权交由操作系统;

## AOF 载入与还原
(1) 创建一个不带网络连接的伪客户端(redis 命令只能在客户端上下文中执行)
(2) 从 AOF 中分析并读取出一条写命令
(3) 使用伪客户端执行写命令
(4) 循环执行, 直到读完

## AOF 重写
AOF 持久化记录的是写命令, 随着时间的推移, 数据量越来越大, 对性能来说, 会有一定影响; 为了解决 AOF 文件体积膨胀问题, Redis 提供了 AOF 重写功能;
从数据库中读取一条数据, 然后创建一条添加语句, 写入到新的 AOF 文件中; 最后用新的 AOF 文件代替老的 AOF 文件;
REDIS_AOF_REWRITE_ITEMS_PER_CMD: 列表, 哈希表, 集合, 有序集合这四种结构, 每个命令的最大 items 数, 默认是 64 个;

## AOF 重写放入子进程的原因
(1) 子进程重写期间, 不影响父进程处理命令请求;
(2) 子进程带有服务器进程的数据副本, 使用子进程而不是子线程, 可以避免使用锁的情况, 保证数据的安全性;

## Redis 如何解决 AOF 重写期间导致的数据不一致问题
(1) 服务端照常执行客户端发来的命令
(2) 将执行后的写命令追加到 AOF 缓冲区和 AOF 重写缓冲区;
(3) 收到子进程重写完成的信号后, 调用信号处理函数;
(4) 将 AOF 重写缓冲区内的内容全部写入到 AOF 文件中;
(5) 原子地更名新的 AOF 文件以覆盖旧的 AOF 文件;


# 事件
Redis 服务器进程就是一个事件循环, 主要处理两种类型的事件:
(1) 文件事件: 服务器与客户端通信会产生文件事件, 服务器通过监听并处理这些文件事件来完成一系列网络通信操作;
(2) 时间事件: 如 serverCron 这种需要在给定时间执行的事件, 叫做时间事件;

## 文件事件
### 文件事件处理器
Redis 采用单线程的 Reactor 模型来设计文件事件处理器, 文件事件处理器包含 IO 多路复用程序, 事件分派器和事件处理器三部分;
IO 多路复用程序监听多个 Socket 操作, 包括 accept, read, write, close 等, 当 Socket 有事件发生, IO 多路复用程序会将事件放入一个队列中;
事件分派器会从队列中获取一个事件, 并选择早已绑定的事件处理器来处理事件, 事件处理完再循环地从队列中获取事件, 整个过程是串行的, 所以说 Redis6.0 之前是单线程模型; 

redis6.0 之前的单线程为什么效率还能那么高?
(1) 纯内存操作, 单个操作很快能完成
(2) IO 多路复用, 不用阻塞等待
(3) 单线程操作不需要上下文切换

redis6.0 之前为什么坚持使用单线程模型?
(1) CPU 并不是瓶颈, 单线程模型效率足够高效;
(2) 多线程实现复杂, 需要考虑读写安全和锁, 这些操作设计复杂且并没有太大的性能提高, 反而可能因为锁竞争导致性能损耗;

Redis6.0 为什么变成多线程
即使引入了多线程, 也只针对 IO 读写这块, 整体上还是坚持单线程的
(1) Redis 性能瓶颈只有网络 IO, 其他地方优化的空间不大
(2) 在事件处理中, [read -> 命令处理 -> write] 的动作是串行操作的, 如果有较大的操作, 会阻塞后续的操作
(3) 现在大多数机器是多核的, 单核单线程太浪费资源了

Redis6.0 还有什么新的改动
(1) IO 多线程
(2) ACL 精细化权限控制
(3) 连接支持 SSL, 更加安全
(4) 提升了 RDB 加载速度

Redis6.0 的多线程模型
针对网络同步网络 IO 的瓶颈, Redis6.0 决定做的改动是, 把 [read -> 命令处理 -> write] 中, read 和 write 的部分, 都用多线程处理, 既能够利用多核, 又能够提高 IO 的性能; 命令处理仍旧是单线程, 串行的; 
特点是:
(1) IO 线程要么同时在读, 要么同时在写, 不存在同时读和同时写;
(2) IO 线程只负责读写 Socket 解析命令, 不负责命令处理;
(3) IO 线程数可自行配置;

什么是 IO 多路复用(No Block IO, NIO)
相对于阻塞 IO, 在内核进行 IO 操作的时候, 程序阻塞等待操作的返回, 造成 CPU 的大浪费, IO 多路复用专门用一个进程负责监听 IO 操作, 一旦有 IO 操作准备就绪, 就通知到程序继续接下来的操作, 这样做的好处是, 能够在 IO 操作的时候处理其他事情, 大大减少了 CPU 的空闲时间;

有哪些 IO 多路复用技术?
(1) select: 需要将一个定长为 1024 的 fd_set 从用户态拷贝到内核态, 需要遍历 fd_set 查找就绪的 IO, 优点是良好的跨平台支持, 缺点是 fd_set 的长度有限, Linux 限制为 1024;
(2) poll: 把 select 的 fd_set 替换为一个结构体指针, 包含要监控的事件和发生的事件, 比 select 改进的是数量限制放开了, 但是依然要遍历事件列表来获取就绪 IO;
(3) epoll: 针对 select 和 poll 每次调用都需要从用户态拷贝数据到内核态的特点, epoll 在内核维护了一个长期存在的数据结构 - 红黑树, 来维护监听的句柄信息, 我们只需要调用 epoll_ctl 中的 ADD, MOD 和 DEL 来对红黑树进行增删改, 而不需要每次都复制大量的数据到内核空间; 第二个改动是使用事件绑定来代替数组或链表扫描, 一旦有事件被触发, 可以直接执行;

epoll 的两种通知模式
LT(Level Trigger): 当文件描述符就绪时, 内核通知到用户程序, 下次 epoll_wait 发现文件还没有被读时, 再继续通知用户程序;
ET(Edge Trigger): 当文件描述符就绪时, 内核只通知用户程序一次, 不在乎用户程序是否去读;

Redis 采用了哪些 IO 多路复用技术
select, epoll, evport, kqueue, 优先级 evport(Solaries 10) > epoll(Linux) > kqueue(OS X, FreeBSD) > select(全平台都支持)

### 事件处理器
连接应答处理器 - 监听套接字 - AE_READABLE 事件;
命令请求处理器 - 客户端套接字 - AE_READABLE 事件;
命令答复处理器 - 客户端套接字 - AE_WRITEABLE 事件;

## 时间事件
服务器将时间事件放在一个无序链表(执行时间无序, 事件 id 有序)中, 每当时间事件运行器运行时, 会遍历链表找到当前需有执行的时间事件, 然后调度时间事件处理器, 如果时间事件返回 AE_NOMORE, 则这个事件执行后解绑删除, 否则, 这是一个周期事件, 重新更新时间事件的执行时间, 放入链表;
目前 Redis 的时间事件只有 serverCron 这一个事件, 所以性能上不会太差;

### serverCron 的职责(默认 200 ms 执行一次)
(1) 定期更新服务器的各类统计信息, 系统时间, 内存占用, 数据库数量等
(2) 定期删除过期 key, 定期删除无效的客户端连接;
(3) 定期尝试进行 AOF 持久化或者 RDB 持久化;
(4) 主服务器定期向从服务器同步数据, 集群模式对集群进行同步和连接测试;

# 客户端/服务器
## 一个客户端请求的执行过程
### 客户端发送连接请求
### 服务端监听连接套接字, 触发 AE_READABLE 事件, 执行连接应答事件处理器
### 连接应答事件处理器创建 redisClient 结构并放入 redisServer 的 client 链表; 创建对应的客户端套接字;

### 客户端发送命令
客户端读取命令请求并转换成协议格式
### 服务端接受命令
服务端监听客户端套接字, 监听到 AE_READABLE 事件, 执行绑定的命令请求处理器;
命令请求处理器从客户端套接字的读缓冲区读内容, 写入 redisClient 的输入缓冲区, 然后解析协议得到 cmd 和 args;
### 服务端执行命令
根据 cmd 去 command table 查找对应的 redisCommand;
执行前进行预检查(cmd 是否为 null, 参数个数, 身份验证, 内存检查, BGSAVE error, 订阅模式/Lua脚本/事务中/载入中等状态下拒绝请求);
执行命令: 执行, 产生回复内容, 回复内容写入写缓冲区, 为客户端套接字关联命令回复处理器;
后续操作: 尝试写满查询日志, 命令技术+1, AOF 写缓冲区, 同步命令到从服务器;
### 服务端回复命令
命令回复事件处理器将客户端输出缓冲区的数据写入客户端套接字的写缓冲区;
清空客户端状态的输出缓冲区;

## severCron 的职责
(1) 更新服务器时间缓存, 系统时间缓存到 unixtime 和 mstime 中;
(2) 为每个 Redis 对象更新 LRU 时钟;
(3) 更新服务器每秒执行命令的次数;
(4) 更新服务器内存峰值记录;
(5) 处理 SIGTERM 信号, 先进行 RDB 持久化再关闭服务器;
(6) 处理客户端资源(超时断开, 清空缓存), 管理服务器资源;
(7) 执行被延迟的 BGREWRITEAOF ;
(8) 检查持久化状态;
(9) AOF 缓冲区内容写入 AOF 文件;
(10) 增加 cronloops 计数器的值;

## 服务端初始化
(1) 初始化服务器默认值
(2) 载入用户自定义配置
(3) 初始化复杂数据结构
(4) 还原数据库状态, 载入 AOF 或 RDB
(5) 执行事件循环 loop

# 复制
复制偏移量, 复制积压缓冲区(定长的队列), 主服务器的运行 ID
如果偏移量+1之后的数据仍在复制积压缓冲区中, 则主服务器将对从服务器执行部分重同步操作; 否则, 执行完整重同步操作;
所以, 复制积压缓冲区的大小很重要, 太小了, 就是去了部分重同步的效果了

从服务器: PSYNC ? -1 首次复制; PSYNC `<runid>` `<offset>` 非初次复制;
主服务器: 完整重复制 FULLRESYNC `<runid>` `<offset>`; 部分重复制 +CONTINUE; 命令识别有误-ERR, 可能是版本低于 2.8;

## 复制的实现步骤
(1) 设置主服务器的地址和端口
(2) 从服务器为主服务器建立套接字连接
(3) 发送 PING 命令
(4) 身份验证
(5) 发送从服务器的端口信息
(6) 同步
(8) 命令传播

## 命令传播阶段, 从服务器对主服务器的心跳检测
命令传播阶段, 从服务器默认每秒向主服务器发送一次 REPLCONF ACK <replication_offset> 命令, 这个命令有三个作用
(1) 检查主从服务器网络连接状态, 如果主服务器超过一秒没有收到从服务器的 REPLCONF ACK 命令, 就认为主从服务器间网络故障
(2) 辅助实现 min-slaves 配置选项, `min-slaves-to-write`, `min-slaves-max-lag` 配置了最少从服务器个数, 从服务器延迟最大值, 如果超过这些条件, 主服务器会拒绝执行写命令;
(3) 检测命令丢失, 通过上传偏移量, 让主服务器知道复制过程中是否有命令丢失


# 集群
## 多种集群模式
(1) Setinel集群: 数据量小
(2) 无主集群: 海量数据

## Redis 与其他 KV 缓存产品相比, 特点是
(1) 持久化
(2) 多种数据结构
(3) 复制集

## Redis 的优势
(1) 性能极高, 读 110000/s, 写 81000/s
(2) 丰富的数据类型
(3) 丰富的特性, 如订阅发布
(4) 原子性, 支持事务

## memocache 与 redis 的区别
(1) 数据持久化
(2) 丰富的数据结构和特性

## Redis 回收策略
(1) volatile-lru: 设置过期的键, 选择 lru
(2) volatile-ttl: 设置过期的键, 选择过期键
(3) volatile-random: 设置过期的键, 任意选择一个
(4) allkeys-lru: 未设置过期的键, 选择 lru
(5) allkeys-random: 未设置过期的键, 任意选择
(6) no-enviction: 不回收

规则: 如果数据幂律分布, 选择 lru, 如果是平等分布, 选择 random;



