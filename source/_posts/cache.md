---
title: cache
date: 2021-08-18 00:00:00
tags: [cache]
categories: cache
comments: true
---

# 缓存穿透
大量的请求进来, 没有命中缓存, 直接回源数据, 对源服务造成很大的压力
(1) 不存在的 key: 把所有的 key 放入一个 BitMap 中, 对请求的 key 进行过滤, 如果 BitMap 中没找到 key, 则这个 key 肯定不存在, 如果找到, 则这个 key 可能存在;
(2) BitMap 认为可能存在的 key:
  存在且有值: 返回
  存在但源数据为空: 把空值也缓存下来 + 缓存后台自动回源;

# 缓存雪崩
## 场景
(1) 缓存组件崩溃
(2) 缓存在同一个时间点全部过期, 对源服务造成很大的压力
缓存不要设置一样的过期时间

# 缓存击穿
同一个请求, 缓存过期时请求量太大, 对源服务造成很大的压力
(1) 写缓存时, 分布式锁
(2) 热点数据永不过期

# cacheloader
1. 在 cachelocader 中, 缓存自动更新组件
(1) 业务上, 通过不同的资源和 user_id 等组合 key, 隔离了不同 key 的并发操作;
(2) 同一个 key, 缓存写时, 记录一个上次写时间, 同 key 的请求并发时, 在 [上次写时间, 上次写时间+ gap 时间] 内的其他请求都不会触发自动回源, 避免起太多 goroutine;
上次写时间记录在一个 [key]time 结构中, map 定长, 使用 LRU 的策略进行切换;
(3) 同一个 key, 缓存过期或者自动回源 gap 时间到时, 如遇到大量请求并发触发自动回源, 需要抢一个分布式的锁, 只有一个请求能成功触发自动回源进行写缓存;
如果 redis 中没有值, 就触发主动回源+异步写缓存;
如果 redis 中有值, 就异步触发回源+写缓存;
(4) 异步写缓存会重新设置过期时间, 热点数据常常写入常常更新过期时间, 基本上不会过期, 防止缓存击穿; 请求量比较少, 请求稀疏的情况下, 缓存也不会主动触发缓存更新, 等到下一个请求进来才开始进行缓存自动更新;
(5) 对每个资源位都可灵活配置返回资源的缓存时间, 缓存过期时间不一致, 防止缓存雪崩;
(6) 回源得到空值也照样缓存, 防止缓存穿透;
(7) 分布式锁, 加锁, 用的是 ``set key val ex deadtime nx``, 原子加锁和设置锁过期时间, 其中 val 是 traceId, 每个请求的标示, deadtime 是可配置的;
(8) 分布式锁, 解锁, 用的是 lua 脚本, ``get key `` 和 `` del key ``;

2. cachloader 限流策略/并发控制
令牌桶算法: 定义一个 maxConcurrency 大小的 channel, 这个在需要控制的入口, 每次运行前拿到一个 token, 运行结束返回这个 token, 否则就只能堵塞或超时;
cacheloader 里面用在了首页资源位调用算法接口的情况下, 算法那边的接口承受能力比较低, 接口比较慢;

3. cacheloader 的意义
一开始对精细化运营系统的预估是美好的, 有大的流量和更快的迭代;
投放系统需要访问各种来源的数据, 有些要求实时, 有些关联内容, 有些关联算法; 针对关联内容和算法的, 如果对方没有足够的优化, 接口响应会难以达到我们的要求, 所以我们会缓存内容, 提高访问速度, 但是我们也要监控对方数据的变化, 避免数据有误, 所以使用缓存自动更新; 一种是频繁更新的数据或者缓存过期时间设置太短, 如果使用先更新 DB 后删除缓存的方式, 那么数据的回源就会直接关联数据的查询, 让 DB 的性能直接影响到接口的响应, 为了减少这种耦合, 使用缓存自动更新解耦 DB 和接口;

# 基于 redis 的分布式锁的注意事项
(1) 加锁: 不能用 ``set nx`` 和 ``expire`` 组合, 这俩命令不是原子的, 如果在 setnx 之后程序崩溃, expire 就失败了, 锁就永远释放不了了! 可以用 ``set key val EX t nx``;
(2) 解锁: 举例, A 拿到锁之后, 执行之间太长, 锁超时自动释放, B 拿到锁, A 执行完之后, A 解锁, 此时, B 运行了一半没锁了, B 解锁不了了; 解决办法, 每个 key 的 val 都是唯一值, 来区分不同的请求; 如 trace_id;
(3) 锁的 expireTime 太短: 举例, A 拿到锁之后, 执行之间太长, 锁超时自动释放, B 拿到锁, 此时 A, B 同时运行, 这是不允许的, 此时可以通过, 设置更长的过期时间, 或者开启一个守护线程来动态延长过期时间来解决;

引用:
https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/
